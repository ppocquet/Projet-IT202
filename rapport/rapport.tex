\documentclass{article}

\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}

%%%%%%%%%%%%%%%% Lengths %%%%%%%%%%%%%%%%
\setlength{\textwidth}{15.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\oddsidemargin}{0.5cm}

%%%%%%%%%%%%%%%% Variables %%%%%%%%%%%%%%%%

\def\titre{Ordonnanceur de threads}
\def\equipe{Romain BESNARD\\ Amandine GEORGES\\ Lun JIANG\\ Quentin LAMBERT}


\begin{document}

%%%%%%%%%%%%%%%% Header %%%%%%%%%%%%%%%%
\fbox{
  \noindent\begin{minipage}{0.98\textwidth}
  \vskip 0mm
  \noindent
      { \begin{tabular}{p{7.5cm}}
          {\bfseries \sffamily
            Projet de système d'exploitation} \\
          {\itshape \titre}
      \end{tabular}}
      \hfill
      \fbox{\begin{tabular}{l}
          {~\hfill \bfseries \sffamily Equipe :
            \hfill~} \\[2mm]
          \equipe \\

      \end{tabular}}
      \vskip 4mm ~

      ~~~\parbox{0.95\textwidth}{\small \textit{Résumé~:} \sffamily Le
        projet qui nous a été proposé consiste en l'implémentation
        d'un ordonnanceur de threads. Nous étions tenus dans un
        premier temps d'éxecuter un programme exemple manipulant
        certaines primitives du module.}

      \vskip 1mm ~

  \end{minipage}
}

\section {La structure thread}

Un type \verb'thread_t' devait être implémenté, nous avons décidé
qu'il devrait représenter un pointeur vers une structure thread que
nous allons maintenant détailler.\\
% detail et justification de la structure thread
\begin{verbatim}
struct thread {
    ucontext_t uc;
    void *retval;
    struct GList * sleeping_list;
}
\end{verbatim}
Le champ \verb'uc' sert à conserver le contexte d'exécution du thread,
\verb'retval' quant à lui permet de stocker la valeur de retour du
thread pour pouvoir remettre cette information aux threads dormants.
Le dernier champ est la liste des threads dormants dans l'attente de
la fin de l'exécution de ce thread.

\section {Les threads dans l'état "ready" et "zombie"}

Nous avons choisi de stocker ces threads dans deux listes distinctes
pour chacun des états. Les threads "ready" sont ceux prêts à
s'exécuter, et les "zombies" ont terminé leur exécution et attendent
que leur valeur de retour soit récupérée.\\
Nous avons pris comme convention que la tête de la liste "ready" est
le thread en cours d'exécution.

\section {Utilisation de la GLib}

Pour nous abstraire de l'implementation du TAD list nous avons utilisé
la GLib, nous fournissant les fonctions nécessaires à la manipulation
des listes de threads tout en nous assurant qu'il n'y aura aucune
fuite mémoire.

\section {L'implémentation des fonctions}

\begin{verbatim}
thread_t thread_self(void);
\end{verbatim}
Avec notre choix de mettre le thread en tête de la liste "ready", 
cette fonction renvoie just la tête de la liste "ready".
~~\\
\begin{verbatim}
int thread_create(thread_t *newthread, void *(*func)(void *), void *funcarg);
\end{verbatim}

Cette fonction a la responsablité d'ajouter le thread main dans la liste "ready", 
si c'est la première fois qu'on crée un thread. 
Comme la liste "ready" est initiallement vide,  elle verifie donc si cette liste est vide, et si c'est le cas, 
elle alloue une instance de la structure thread, 
sauvegarde le contexte du main dans cette instance et la place à la tête de la liste.
Puis elle crée une instance de la structure thread avec la fontion
passée en paramètre et retourne un thread_t pointant sur cette structure.
~~\\
\begin{verbatim}
int thread_yield(void);
\end{verbatim}
Cette fontion fait un $swapcontext$ sur le contexte de la tête de 
la liste "ready" (qui est le thread courant) et celui de l'élément suivant.
~~\\
\begin{verbatim}
int thread_join(thread_t thread, void **retval);
\end{verbatim}
Cette fonction verifie tout d'abord, si le thread qu'on veut 
attendre est dans la liste "ready". si c'est le cas 
alors elle se met dans la liste des dormants de ce thread et passe la main au suivant.
Sinon elle verifie si ce thread est la liste "zombie", 
si c'est le cas alors elle prend la valeur de retour de ce thread et continue son exécution.
Enfin si ce thread n'est pas dans la liste "zombie" 
alors elle retourne -1 pour dire que l'appel a échoué et que ce thread n'existe pas.
~~\\   
\begin{verbatim}
void thread_exit(void *retval);
\end{verbatim}
Cette fonction réveille tous les threads de sa liste des dormants et
 met à jour son champ retval avec la valeur en paramètre. Puis elle se met dans la liste "zombie" et passe la main au suivant.
\end{document}

