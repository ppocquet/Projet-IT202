\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage[french]{babel}
\usepackage[utf8]{inputenc}

%%%%%%%%%%%%%%%% Lengths %%%%%%%%%%%%%%%%
\setlength{\textwidth}{15.5cm}
\setlength{\evensidemargin}{0.5cm}
\setlength{\oddsidemargin}{0.5cm}

%%%%%%%%%%%%%%%% Variables %%%%%%%%%%%%%%%%

\def\titre{Ordonnanceur de threads}
\def\equipe{Romain BESNARD\\ Amandine GEORGES\\ Lun JIANG\\ Quentin LAMBERT}


\begin{document}

%%%%%%%%%%%%%%%% Header %%%%%%%%%%%%%%%%
\fbox{
  \noindent\begin{minipage}{0.98\textwidth}
  \vskip 0mm
  \noindent
      { \begin{tabular}{p{7.5cm}}
          {\bfseries \sffamily
            Projet de système d'exploitation} \\
          {\itshape \titre}
      \end{tabular}}
      \hfill
      \fbox{\begin{tabular}{l}
          {~\hfill \bfseries \sffamily Equipe :
            \hfill~} \\[2mm]
          \equipe \\

      \end{tabular}}
      \vskip 4mm ~

      ~~~\parbox{0.95\textwidth}{\small \textit{Résumé~:} \sffamily Le
        projet qui nous a été proposé consiste en l'implémentation
        d'un ordonnanceur de threads. Nous étions tenus dans un
        premier temps d'exécuter un programme exemple manipulant
        certaines primitives du module et de tester ces primitives sur
        des programmes utilisant plusieurs threads, comme
        Fibonacci. Dans un second temps, nous devions choisir
        plusieurs objectifs avancés à implémenter.}

      \vskip 1mm ~

  \end{minipage}
}

~~\\
~~\\

\input{libthread.tex}
\input{ordo.tex}
\input{preempt.tex}
\input{signal.tex}
\input{conclusion.tex}


%% \section{La mémoire}
%% Pour l'instant aucune libération de mémoire n'est faite. En
%% particulier nous ne nous sommes pas encore posé la question de quand
%% libérer les threads de la liste zombie. Cela pose un problème
%% évident lorsque le nombre de threads devient important. Nous nous
%% attellerons donc en priorité à la résolution de ce problème.

%% \section{Améliorations prévue}
%% Nous avons implémenté les programmes parallèles du calcul de la suite
%% de Fibonacci et de la somme des élément d'un tableau par
%% diviser-pour-régner. Cela nous permettra de tester les performances de
%% notre bibliothèque, en évaluant le temps d'exécution en fonction de la
%% taille de l'entrée. Il nous semble que la gestion du thread principal
%% est déjà prise en compte, il conviendra de s'en assurer. Nous pensons
%% mettre au point des fonctions de synchronisation de type
%% sémaphore. Nous aimerions aussi nous pencher sur la gestion de la
%% préemption et des signaux.

\end{document}
